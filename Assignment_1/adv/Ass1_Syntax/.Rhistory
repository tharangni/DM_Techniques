plot(test)
plot(log10(test))
plot(diff(test))
plot(diff(diff(test)))
HoltWinters(test)
test <- trainData[which(trainData$id == "AS14.01"), c("date", "interp_mood")]
test <- ts(data =  as.data.frame(test), start = 1)
plot(test)
plot(log10(test))
plot(diff(test))
plot(diff(diff(test)))
HoltWinters(test)
auto.arima(test)
auto.arima(test[, 2])
auto.arima(test[, 2], d = 1)
acf(test[, 2])
pacf(test[, 2])
acf(diff(test[, 2]))
plot(test[, 2])
model <- auto.arima(test[, 2])
model
model$fitted
model$fitted - model$x
sum(model$fitted - model$x)
model
forecast(model)
model <- auto.arima(test[, 2])
forecast(object = model)
forecast(object = model, h = 10)
plot(test[, 2])
pacf(log(test[, 2]))
acf(log(test[, 2]))
model <- arima(test[, 2], order = c(0, 1, 3))
forecast(object = model, )
View(testData)
test <- trainData[which(trainData$id == "AS14.02"), c("date", "interp_mood")]
test <- ts(data =  as.data.frame(test), start = 1)
plot(test[, 2])
acf(log(test[, 2]))
pacf(log(test[, 2]))
model <- arima(test[, 2], order = c(0, 1, 1))
forecast(object = model, )
model
model <- arima(test[, 2], order = c(4, 1, 1))
model
model <- arima(test[, 2], order = c(2, 1, 1))
model
model <- arima(test[, 2], order = c(1, 1, 1))
model
model <- arima(test[, 2], order = c(0, 1, 1))
model
model <- arima(test[, 2], order = c(0, 2, 1))
model
model <- arima(test[, 2], order = c(0, 1, 0))
model
forecast(object = model, )
model <- arima(test[, 2], order = c(0, 0, 1))
model
model <- arima(test[, 2], order = c(1, 0, 1))
model
model <- arima(test[, 2], order = c(2, 0, 1))
model
model <- arima(test[, 2], order = c(1, 0, 2))
model
model <- arima(test[, 2], order = c(1, 0, 0))
model
model <- arima(test[, 2], order = c(1, 0, 1))
model
model <- arima(test[, 2], order = c(0, 0, 1))
model
forecast(object = model, )
model <- auto.arima(test[, 2])
model
forecast(object = model)
model <- auto.arima(test[, 2])
model
f = forecast(object = model)
f
test <- trainData[which(trainData$id == "AS14.03"), c("date", "interp_mood")]
test <- ts(data =  as.data.frame(test), start = 1)
plot(test[, 2])
acf(log(test[, 2]))
pacf(log(test[, 2]))
model <- auto.arima(test[, 2])
model
forecast(object = model)
View(testData)
f = forecast(object = model)
f$fitted
f$residuals
f$method
f$level
f$mean
forecast(object = model)
f$series
HoltWinters(test[, 2]))
HoltWinters(test[, 2])
HoltWinters(test)
test <- ts(data =  as.data.frame(test), start = 1, frequency = 1)
plot(test[, 2])
acf(log(test[, 2]))
pacf(log(test[, 2]))
model <- auto.arima(test[, 2])
model
f = forecast(object = model)
f$mean
HoltWinters(test)
fit <- tbats(test[, 2])
fc <- forecast(fit, h=20)
fc <- forecast(fit, h=20)
fc
fc <- forecast(fit, h=10)
sum(f$mean*f$mean)
sum(fc$mean*fc$mean)
plot(fc)
fit <- tbats(log(test[, 2]))
fc <- forecast(fit, h=10)
plot(fc)
fit <- tbats(diff(log(test[, 2])))
fc <- forecast(fit, h=10)
plot(fc)
sum(f$residuals*f$residuals)
sum(cf$residuals*fc$residuals)
sum(fc$residuals*fc$residuals)
plot(model)
f$mean
View(testData)
######################################
#Install packages, if not available
# install.packages("data.table")
# install.packages("lubridate")
# install.packages("GGally")
######################################
######################################
#Load packages
library(data.table)
library(lubridate)
library(ggplot2)
library(GGally)
######################################
######################################
#Load data
Mood <- fread("../dataset_mood_smartphone.csv", na.strings = c("NA"), dec = c("."))
######################################
######################################
#Delete useless variables
# T: I don't think V1 is useless as the values start differing with the serial
# number from count '143507' onwards. So this part needs be reasoned why you
# think it needs to be deleted if you still think it's useless.
# K: Because it is a subset of the original dataset.
Mood$V1 <- NULL
######################################
######################################
#Check out data
str(Mood)
summary(Mood)
#Matches from what is in Excel
######################################
######################################
#Reshape Data
newdata <- reshape(Mood,
timevar = "variable",
idvar = c("id", "time"),
direction = "wide")
######################################
######################################
#Define variable as "time" format - full date and time
newdata$converted.time <- as_datetime(newdata$time)
#Define date variable
newdata$date <- as_date(newdata$time)
#Define hour variable (hour of the day)
newdata$hour <- hour(newdata$converted.time)
#Use hour of the day to define time of day
newdata$time.of.day[newdata$hour <= 6] <- "dawn"
newdata$time.of.day[newdata$hour > 6 & newdata$hour <= 12] <- "morning"
newdata$time.of.day[newdata$hour > 12 & newdata$hour <= 18] <- "afternoon"
newdata$time.of.day[newdata$hour > 18 & newdata$hour <= 24] <- "evening"
#Add Weekday
newdata$week.day <- weekdays(newdata$date)
######################################
######################################
#Sort by id and date
newdata <- newdata[order(id, converted.time),]
######################################
#Add nth day into newdata (column)
min_day <- as.numeric(min(newdata$date))
newdata$nth_day <- as.numeric(unlist(lapply(X = as.numeric(newdata$date), FUN = function(x) x+1-min_day)))
rm(min_day)
######################################
#AGGREGATE DATA (DAILY LEVEL)
#make sure that newdata is loaded in environment - from ReadData.R
#This syntax:
# - creates interesting variables
# - aggregates the data
# - prepares the data for modelling
######################################
######################################
#Install packages, if not available
install.packages("zoo")
######################################
######################################
#Load package
library(zoo)
######################################
######################################
# Create variables number of times each
# application was open throughout the day (use the sum in aggregation to get this value).
newdata$count_value.appCat.builtin <- ifelse(is.na(newdata$value.appCat.builtin) == FALSE,
newdata$count_value.appCat.builtin <- 1,
newdata$count_value.appCat.builtin <- 0)
newdata$count_value.appCat.communication <- ifelse(is.na(newdata$value.appCat.communication) == FALSE,
newdata$count_value.appCat.communication <- 1,
newdata$count_value.appCat.communication <- 0)
newdata$count_value.appCat.entertainment <- ifelse(is.na(newdata$value.appCat.entertainment) == FALSE,
newdata$count_value.appCat.entertainment <- 1,
newdata$count_value.appCat.entertainment <- 0)
newdata$count_value.appCat.finance <- ifelse(is.na(newdata$value.appCat.finance) == FALSE,
newdata$count_value.appCat.finance <- 1,
newdata$count_value.appCat.finance <- 0)
newdata$count_value.appCat.game <- ifelse(is.na(newdata$value.appCat.game) == FALSE,
newdata$count_value.appCat.game <- 1,
newdata$count_value.appCat.game <- 0)
newdata$count_value.appCat.office <- ifelse(is.na(newdata$value.appCat.office) == FALSE,
newdata$count_value.appCat.office <- 1,
newdata$count_value.appCat.office <- 0)
newdata$count_value.appCat.other <- ifelse(is.na(newdata$value.appCat.other) == FALSE,
newdata$count_value.appCat.other <- 1,
newdata$count_value.appCat.other <- 0)
newdata$count_value.appCat.social <- ifelse(is.na(newdata$value.appCat.social) == FALSE,
newdata$count_value.appCat.social <- 1,
newdata$count_value.appCat.social <- 0)
newdata$count_value.appCat.travel <- ifelse(is.na(newdata$value.appCat.travel) == FALSE,
newdata$count_value.appCat.travel <- 1,
newdata$count_value.appCat.travel <- 0)
newdata$count_value.appCat.unknown <- ifelse(is.na(newdata$value.appCat.unknown) == FALSE,
newdata$count_value.appCat.unknown <- 1,
newdata$count_value.appCat.unknown <- 0)
newdata$count_value.appCat.utilities <- ifelse(is.na(newdata$value.appCat.utilities) == FALSE,
newdata$count_value.appCat.utilities <- 1,
newdata$count_value.appCat.utilities <- 0)
newdata$count_value.appCat.weather <- ifelse(is.na(newdata$value.appCat.weather) == FALSE,
newdata$count_value.appCat.weather <- 1,
newdata$count_value.appCat.weather <- 0)
######################################
######################################
# Aggregate data on by day and id.
aggData = newdata[, .(count = .N,
agg_mood = mean(value.mood, na.rm=TRUE),
agg_arousal = mean(value.circumplex.arousal, na.rm=TRUE),
agg_valence = mean(value.circumplex.valence, na.rm=TRUE),
agg_activity = mean(value.activity, na.rm=TRUE),
agg_screen = mean(value.screen, na.rm=TRUE),
agg_call = sum(value.call, na.rm=TRUE),
agg_sms = sum(value.sms, na.rm=TRUE),
agg_builtin = mean(value.appCat.builtin, na.rm=TRUE),
agg_communication = mean(value.appCat.communication, na.rm=TRUE),
agg_entertainment = mean(value.appCat.entertainment, na.rm=TRUE),
agg_finance = mean(value.appCat.finance, na.rm=TRUE),
agg_game = mean(value.appCat.game, na.rm=TRUE),
agg_office = mean(value.appCat.office, na.rm=TRUE),
agg_other = mean(value.appCat.other, na.rm=TRUE),
agg_social = mean(value.appCat.social, na.rm=TRUE),
agg_travel = mean(value.appCat.travel, na.rm=TRUE),
agg_unknown = mean(value.appCat.unknown, na.rm=TRUE),
agg_utilities = mean(value.appCat.utilities, na.rm=TRUE),
agg_weather = mean(value.appCat.weather, na.rm=TRUE),
agg_count_builtin = sum(count_value.appCat.builtin, na.rm=TRUE),
agg_count_communication = sum(count_value.appCat.communication, na.rm=TRUE),
agg_count_entertainment = sum(count_value.appCat.entertainment, na.rm=TRUE),
agg_count_finance = sum(count_value.appCat.finance, na.rm=TRUE),
agg_count_game = sum(count_value.appCat.game, na.rm=TRUE),
agg_count_office = sum(count_value.appCat.office, na.rm=TRUE),
agg_count_other = sum(count_value.appCat.other, na.rm=TRUE),
agg_count_social = sum(count_value.appCat.social, na.rm=TRUE),
agg_count_travel = sum(count_value.appCat.travel, na.rm=TRUE),
agg_count_unknown = sum(count_value.appCat.unknown, na.rm=TRUE),
agg_count_utilities = sum(count_value.appCat.utilities, na.rm=TRUE),
agg_count_weather = sum(count_value.appCat.weather, na.rm=TRUE)),
by = .(id, date)]
######################################
# Include other more interesting variables
# Add weekday
aggData$weekday <- weekdays(aggData$date)
# Count number of different applications used per day
aggData$open_count <- aggData[,apply(X = aggData[, 11:22], MARGIN = 1, FUN = function(x) sum(!is.nan(x)))]
######################################
######################################
#Exclude data with missing Mood
PreData <- subset(aggData, (!is.nan(aggData[, aggData$agg_mood]) | !is.nan(aggData[, aggData$agg_screen]) ))
######################################
######################################
#Interpolate missing values for mood, arousal and valence
PreData$interp_mood <- na.approx(PreData$agg_mood, na.rm = FALSE)
PreData$interp_arousal <- na.approx(PreData$agg_arousal, na.rm = FALSE)
PreData$interp_valence <- na.approx(PreData$agg_valence, na.rm = FALSE)
#remove non interpolated variables
PreData$agg_mood <- NULL
PreData$agg_arousal <- NULL
PreData$agg_valence <- NULL
######################################
######################################
#Visualise correlations
ggcorr(data = PreData, label = TRUE, label_alpha = TRUE, label_size = 2.5, label_round = 2,
hjust = 1, size = 3)
######################################
library(forecast)
source("./Helper_Functions.R")
TimeSeriesData <- PreData[, .(id, date, interp_mood)]
TimeSeriesData$date <- as.Date(TimeSeriesData$date)
SplitData <- splitdata_id(TimeSeriesData)
trainData <- rbind(SplitData[[1]], SplitData[[2]])
testData <- SplitData[[3]]
for (user_id in unique(trainData$id))
3r
test <- trainData[which(trainData$id == "AS14.03"), c("date", "interp_mood")]
test <- ts(data =  as.data.frame(test), start = c(1))
test
library(forecast)
#For every ID make a model and forecast that model
for (user_id in unique(trainData$id)) {
#Subset user data
dfUser <- trainData[which(trainData$id == user_id), c("date", "interp_mood")]
#Create a time series frame
dfUser <- ts(data =  as.data.frame(dfUser), start = c(1))
#Create ARIMA model
model <- auto.arima(dfUser[, 2])
#Get test data for specific user
dfUserTest <- testData[which(testData$id == user_id), c("interp_mood")]
print(dfUserTest)
#Define how many forecast point necessary
f_days <- length(dfUserTest)
#Forecast model for length of test data (f_days)
forecastModel = forecast(object = model, h = f_days)
}
#initialise c() with forecasted data
finalForecast <- c()
for (user_id in unique(trainData$id)) {
#Subset user data
dfUser <- trainData[which(trainData$id == user_id), c("date", "interp_mood")]
#Create a time series frame
dfUser <- ts(data =  as.data.frame(dfUser), start = c(1))
#Create ARIMA model
model <- auto.arima(dfUser[, 2])
#Get test data for specific user
dfUserTest <- testData[which(testData$id == user_id), c("interp_mood")]
#Define how many forecast point necessary
f_days <- length(dfUserTest)
#Forecast model for length of test data (f_days)
forecastModel = forecast(object = model, h = f_days)
#Concatenate forecast to finalForecast
finalForecast <- rbind(finalForecast, forecastModel$mean)
}
#Append new forecasted values to testData
testData$forecast_mood <- finalForecast
test <- trainData[which(trainData$id == "AS14.03"), c("date", "interp_mood")]
test <- ts(data =  as.data.frame(test), start = c(1))
plot(test[, 2])
acf(log(test[, 2]))
pacf(log(test[, 2]))
model <- auto.arima(test[, 2])
model
f = forecast(object = model)
f$mean
f$mean
f$mean[1]
t = f$mean
t
t = f$mean[]
t
View(testData)
typeof(t)
summary(t)
tt = unclass(t)
tt
tt[1]
tt[[1]]
tt
class(t)
as.numeric(t)
t
tt = as.numeric(t)
tt
tt[2]
tt[:]
tt[]
finalForecast <- c()
for (user_id in unique(trainData$id)) {
#Subset user data
dfUser <- trainData[which(trainData$id == user_id), c("date", "interp_mood")]
#Create a time series frame
dfUser <- ts(data =  as.data.frame(dfUser), start = c(1))
#Create ARIMA model
model <- auto.arima(dfUser[, 2])
#Get test data for specific user
dfUserTest <- testData[which(testData$id == user_id), c("interp_mood")]
#Define how many forecast point necessary
f_days <- length(dfUserTest)
#Forecast model for length of test data (f_days)
forecastModel = forecast(object = model, h = f_days)
#TODO get values from mean
#Concatenate forecast to finalForecast
finalForecast <- rbind(finalForecast, as.numeric(forecastModel$mean))
}
#Append new forecasted values to testData
testData$forecast_mood <- finalForecast
View(finalForecast)
as.numeric(forecastModel$mean)
as.numeric(forecastModel$mean)
forecastModel$mean
f_days
length(dfUserTest)
dfUserTest
length(dfUserTest)
dfUserTest
class(dfUserTest)
dim(dfUserTest)
dim(dfUserTest)[1]
source("./Helper_Functions.R")
source("./Helper_Functions.R")
testData_f <- forecast_ARIMA(trainData, testData)
source("./Helper_Functions.R")
testData_f <- forecast_ARIMA(trainData, testData)
warnings()
source("./Helper_Functions.R")
testData_f <- forecast_ARIMA(trainData, testData)
as.numeric(forecastModel$mean)
source("./Helper_Functions.R")
testData_f <- forecast_ARIMA(trainData, testData)
source("./Helper_Functions.R")
testData_f <- forecast_ARIMA(trainData, testData)
testData_f <- forecast_ARIMA(trainData, testData)
warnigns()
warnings()
View(testData_f)
f
t
tt
View(testData_f)
source("./Helper_Functions.R")
testData_f <- forecast_ARIMA(trainData, testData)
f$mean
test <- as.numeric(f$mean)
test
test[1]
test[2]
dim(test)
length(test)
source("./Helper_Functions.R")
testData_f <- forecast_ARIMA(trainData, testData)
source("./Helper_Functions.R")
testData_f <- forecast_ARIMA(trainData, testData)
View(testData_f)
source("./Helper_Functions.R")
testData_f <- forecast_ARIMA(trainData, testData)
View(testData_f)
source("./Helper_Functions.R")
testData_f <- forecast_ARIMA(trainData, testData)
View(testData_f)
source("./Helper_Functions.R")
testData_f <- forecast_ARIMA(trainData, testData)
View(testData_f)
library(ModelMetrics)
rmse(actual = testData_f$interp_mood, predicted = testData_f$forecast_mood)
c = rmse(actual = testData_f$interp_mood, predicted = testData_f$forecast_mood)
c
testData_f$interp_mood - testData_f$forecast_mood
(testData_f$interp_mood - testData_f$forecast_mood) ^2
source("./Helper_Functions.R")
Performance(actual = testData_f$interp_mood, predicted = testData_f$forecast_mood)
source("./Helper_Functions.R")
Performance(actual = testData_f$interp_mood, predicted = testData_f$forecast_mood)
source("./Helper_Functions.R")
Performance(actual = testData_f$interp_mood, predicted = testData_f$forecast_mood)
source("./Helper_Functions.R")
Performance(actual = testData_f$interp_mood, predicted = testData_f$forecast_mood)
model$aic
source("./Helper_Functions.R")
forecast_ARIMA_manual(trainData, testData)
source("./Helper_Functions.R")
forecast_ARIMA_manual(trainData, testData)
source("./Helper_Functions.R")
forecast_ARIMA_manual(trainData, testData)
source("./Helper_Functions.R")
model <- arima(test[, 2], method="ML")
test <- trainData[which(trainData$id == "AS14.03"), c("date", "interp_mood")]
test <- ts(data =  as.data.frame(test), start = c(1))
plot(test[, 2])
acf(log(test[, 2]))
pacf(log(test[, 2]))
model <- arima(test[, 2], method="ML")
model$coef
model
source("./Helper_Functions.R")
forecast_ARIMA_manual(trainData, testData)
testData_m <- forecast_ARIMA_manual(trainData, testData)
#Compare using RMSE
rmse(actual = testData_m$interp_mood, predicted = testData_m$forecast_mood)
#Compare using neighbour
Performance(actual = testData_m$interp_mood, predicted = testData_m$forecast_mood)
######################################
#Compare using RMSE
rmse(actual = testData_f$interp_mood, predicted = testData_f$forecast_mood)
#Compare using neighbour
Performance(actual = testData_f$interp_mood, predicted = testData_f$forecast_mood)
rmse(actual = testData_f$interp_mood, predicted = testData_f$forecast_mood)
rmse(actual = testData_m$interp_mood, predicted = testData_m$forecast_mood)
Performance(actual = testData_f$interp_mood, predicted = testData_f$forecast_mood)
Performance(actual = testData_m$interp_mood, predicted = testData_m$forecast_mood)
source("./Helper_Functions.R")
testData_m <- forecast_ARIMA_manual(trainData, testData)
source("./Helper_Functions.R")
View(testData_f)
